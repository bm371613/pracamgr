\documentclass{pracamgr}

\usepackage{polski}

\usepackage[latin2]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{graphicx}

\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother

\author{Bartosz Marcinkowski}

\nralbumu{319476}

\title{Sztuczna inteligencja na przykladzie gry Quoridor}
\tytulang{Artificial intelligence for the Quoridor game}

\kierunek{Informatyka}

\opiekun{prof. Jana Madeya}

\date{Maj 2016}

\dziedzina{11.3 Informatyka}

\klasyfikacja{
I. Computing Methodologies \\
  I.2. Artificial intelligence \\
  I.2.1. Applications and Expert Systems}

\keywords{
	sztuczna inteligencja, gry planszowe
}

% Tu jest dobre miejsce na Twoje w³asne makra i~¶rodowiska:
\newtheorem{defi}{Definicja}[section]

% koniec definicji

\begin{document}
\maketitle

\begin{abstract}
TODO
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables


\chapter{Wprowadzenie}

W pracy zajmiemy siê sztuczn± inteligencj± dla gry Quoridor. W dalszej czê¶ci pierwszego rozdzia³u opiszemy zasady gry w wersji oryginalnego wydawcy i wska¿emy istniej±ce niedoskona³o¶ci, okre¶limy za³o¿enia i oczekiwania wobec tej pracy i dokonamy przegl±du istniej±cych rozwi±zañ, aby uzasadniæ podjêcie tematu. W drugim rodziale dokonamy przegl±du ogólnych metod szcztucznej inteligencji u¿ywanych do implementacji graczy komputerowych. W trzecim rozdziale rozstrzygniemy kwestiê zasad gry. W czwartym opiszemy i uzasadnimy wybór technologii u¿ytych do implementacji i porównywania rozwa¿anych pó¼niej algorytmów. W pi±tym rozdziale opiszemy proces rozwijania kolejnych algorytmów, a¿ w koñcu w szóstym podsumujemy efekty naszej pracy.

\section{Quoridor - oryginalne zasady gry}

Gra rozgrywa siê na planszy za pomoc± 4 pionków i 20 ogrodzeñ, nazywanych te¿ ¶cianami. Na planszy znajduje siê siatka szczelin wyznaczaj±ca 81 kwadratowych pól, tworz±cych uk³ad 9~x~9. Ka¿dy pionek ma unikatowy kolor, mie¶ci siê na jednym polu planszy i nie mo¿e go dzieliæ z innym. Ogrodzenia s± identyczne i daj± siê umieszczaæ w szczelinach miêdzy polami planszy. Ogrodzenie jest dwukrotnie d³u¿sze od boku pola, wiêc (poprawnie umieszczone) s±siaduje z dwoma polami z ka¿dej strony, zajmuje ca³± szeroko¶æ szczeliny i jedno skrzy¿owanie szczelin.

W grze mo¿e wzi±æ udzia³ dwóch lub czterech graczy. W obu przypadkach otrzymuj± po jednym pionku, dziel± siê po równo ogrodzeniami i przypisuj± siê do ró¿nych boków planszy; je¿eli jest ich dwóch, musz± to byæ boki przeciwleg³e.

Na pocz±tku gry na planszy nie ma ogrodzeñ (stanowi± zasoby graczy), a pionek ka¿dego gracza umieszcza siê na polu przy ¶rodku boku, do którego jest przypisany.
Nastêpnie gracze wykonuj± kolejno swoje ruchy. Celem gry jest dotarcie swoim pionkiem do boku planszy przeciwleg³ego wobec boku, do którego jest siê przypisanym. Gra koñczy siê w momencie, w którym jednemu z graczy siê to uda.

Ka¿dy ruch mo¿e polegaæ na ustawieniu jednego ze swoich nieu¿ytych ogrodzeñ na planszy albo przesuniêciu pionka. Ogrodzenie nie mo¿e kolidowaæ z ¿adnym innym i nie mo¿e odci±æ ¿adnemu graczowi wszystkich dróg do celu. Ruch pionkiem polega na przesuniêciu go na puste, s±siadnie pole (s±siedztwo wyznacza wspólny bok).

Je¿eli na pewnym s±siednim, nieodgrodzonym polu znajduje siê ju¿ pionek przeciwnika, mo¿na wykonaæ skok na pole za tym pionkiem, o ile jest ono puste i nieodgrodzone. Je¿eli taki skok nie jest mo¿liwy, mo¿na wykonaæ skok na jedno z dwóch pozosta³ych pól s±siaduj±cych z przeciwnikiem, znów o ile jest puste i nieodgrodzone.

\section{Niedoskona³o¶æ oryginalnych zasad}

Dla pewnych stanów gry oryginalne zasady nie odpowiadaj± jednoznacznie na pytanie o legalne ruchy albo daj± odpowied¼ nieoczekiwan±, wygl±daj±c± na efekt niedopatrzenia. Mo¿liwe, ¿e autorzy i wydawcy gry ¶wiadomie woleli pozostawiæ ma³o prawdopodobne sytuacje do rozs±dzenia graczom ni¿ wyd³u¿aæ instrukcjê analizami kolejnych przypadków, jednak w przypadku tej pracy takie podej¶cie jest niedopuszczalne. Automatyczne testowanie algorytmów sztucznej inteligencji zwiêksza prawdopodobieñstwo natrafienia na problematyczne stany gry, co mo¿e zaburzyæ wynik pracy. W tym miejscu zarysujemy tylko problem przyk³adem, odk³adaj±c rozwa¿ania nad mo¿liwymi rozwi±zaniami na dalsz± czê¶æ pracy.

\subsection*{Brak legalnych ruchów}

Niech pionki czarny i zielony s±siaduj± z pionkiem czerwonym. Dalej, niech pionek czarny bêdzie odgrodzony od wszystkich s±siednich pól oprócz tego, na którym stoi czerwony i niech czerwony bêdzie odgrodzony od tych pól, na których nie stoj± czarny ani zielony. Teraz, je¿eli w³a¶ciciel pionka czarnego nie ma ju¿ ogrodzeñ, nie mo¿e wykonaæ ruchu.

\begin{figure}[ht!]
\centering
\includegraphics[width=120mm]{img/no-move.png}
\caption{Brak legalnych ruchów \label{overflow}}
\end{figure}

\section{Cele i za³o¿enia}

Opracowywanie graczy sterowanych komputerowo do gier planszowych mo¿e mieæ ró¿ne za³o¿enia i cele. Pe³ne rozwi±zanie gier z du¿± ilo¶ci± stanów wymaga mocy obliczeniowej przekraczaj±cej mo¿liwo¶ci komputera osobistego, a nawet je¶li uzyska siê je na superkomputerze, to wynikowa tablica optymalnych ruchów nie nadaje siê do dystrybucji wraz z gr±. Celem tej pracy jest opracowanie algorytmów sztucznej inteligencji dla gry Quoridor i utworzenie oprogramowania open-source, ³atwego w dystrybucji i nadaj±cego siê do u¿ycia na komputerze osobistym lub urz±dzeniu przeno¶nym, które bêdzie umo¿liwa³o grê cz³owieka przeciwko ró¿nym algorytmom, obserwowanie rozgrywek miêdzy graczami komputerowymi oraz porównywanie graczy komputerowych poprzez przeprowadzanie automatycznych turniejów (w tym ostatnim przypadku bez interfejsu dla u¿ytkownika).

Dodatkowo chcieliby¶my rozwi±zaæ problem responsywno¶ci gracza komputerowego, który pojawia siê w wielu aplikacjach. Mianowicie chcieliby¶my unikn±æ rozwi±zañ, w których czas dzia³ania algorytmu jest regulowany parametrem specyficznym dla danego algorytmu sztucznej inteligencji, np. g³êboko¶ci± przeszukiwania drzewa stanów gry, i dopiero po wykonaniu ca³ego algorytmu zwracany jest wynik. Takie rozwi±zania nie gwarantuj± w rzeczywisto¶ci ¿adnego ograniczenia na czas w jakim komputer wykona ruch. Zamiast tego, chcieliby¶my zaprojektowaæ algorytmy w taki sposób, ¿eby w mo¿na by³o przerwaæ ruch gracza komputerowego w dowolnym momencie, uzyskuj±c decyzjê o ruchu, który wydawa³ siê optymalny w podczas przerwania obliczeñ, i jednocze¶nie nie uzyskaæ algorytmu silnie uzale¿nionego od czynników losowych, jak np. kolejno¶æ rozpatrywania dopuszczalnych ruchów.

\section{Istniej±ce rozwi±zania}

W¶ród projektów open-source dotycz±cych gry Quoridor, które znale¼li¶my, ¿aden nie zawiera zadowalaj±cego algorytmu sztucznej inteligencji. S± to albo serwery gry, zajmuj±ce siê wy³±cznie przestrzeganiem zasad gry i pozostawiaj±ce wybór ruchu poza zakresem projektu, albo aplikacje pozwalaj±ce graæ z naiwnym graczem komputerowym. Nie widaæ te¿ w prób rozwi±zania problemu responsywno¶ci.

\chapter{Podstawowe metody sztucznej inteligencji dla gier}

Istniej± standardowe, ogólne metody tworzenia algorytmów sztucznej inteligencji graczy komputerowych, które korzystaj± z podobnych za³o¿eñ i abstrakcji. W tym rozdziale opiszemy te za³o¿enia i metody, a pó¼niej odniesiemy je do gry Quoridor i przyjêtych wcze¶niej za³o¿eñ.

\section{Podstawowe pojêcia}

Algorytmy, które tu przedstawimy, dotycz± deterministycznych gier dla dwóch graczy, o sumie zerowej, z pe³n± informacj± o stanie gry, w których gracze wykonuj± ruchy na zmianê. Suma zerowa oznacza, ¿e wygrana jednego gracza oznacza przegran± drugiego.

Podstawow± abstrakcj± u¿ywan± do reprezentacji gry jest graf skierowany, w którym wierzcho³ki reprezentuj± stany gry, a krawêdzie reprezentuj± legalne ruchy. Rozgrywka jest reprezentowana przez ¶cie¿kê, byæ mo¿e zawieraj±c± cykle, od wierzcho³ka reprezentuj±cego stan pocz±tkowy do jednego z wierzcho³ków reprezentuj±cych stan koñcowy.

Na potrzeby algorytmów sztucznej inteligencji czêsto wygodniej jest u¿yæ drzewa gry, w którym wiele wierzcho³ków mo¿e reprezentowaæ ten sam stan gry. Stan pocz±tkowy jest reprezentowany korzeniem, stany koñcowe li¶æmi a rozgrywka ¶cie¿k± od korzenia do li¶cia.

W dalszej czê¶ci pracy bêdziemy zamiennie u¿ywaæ pojêæ stan i wierzcho³ek, ruch i krawêd¼ itd. o ile nie bêdzie powodowaæ to nieporozumieñ.

Kolejnym pojêciem pojawiaj±cym siê w tych algorytmach jest funkcja oceniaj±ca. Jest to funkcja przypisuj±ca stanowi gry liczbê ca³kowit±, która ma oceniaæ jak bardzo po¿±dany jest ten stan dla dangego gracza. Powinna przyjmowaæ skrajne warto¶ci dla stanów koñcowych (najwiêksz± dla wygrywaj±cych, a najmniejsz± dla przegrywaj±cych).

\section{Minimax i Alfa-Beta}

\subsection{Minimax}

Algorytm Minimax nazywa graczy \(min\) i \(max\) oraz rozpatruje w drzewie gry tylko poddrzewo bie¿±cego stanu gry do ustalonej g³êboko¶ci. W tak uzyskanym drzewie li¶ciom przypisana jest warto¶æ funkcji oceniaj±cej dla gracza \(max\). Pozosta³e wierzcho³ki bêd± mia³y przypisywane warto¶ci na podstawie warto¶ci synów.

Z definicji funkcji oceniaj±cej oczekujemy, ¿e gracz \(max\) zawsze wybierze ruch prowadz±cy do syna o najwiêkszej warto¶ci, wiêc w grze o sumie zerowej gracz \(min\) bêdzie wybiera³ najmniejsze warto¶ci. Zatem warto¶ci \("minimax"\) dla wszystkich wierzcho³ków mo¿emy obliczyæ nastêpuj±co:

\begin{algorithm}
\caption{minimax}\label{minimax}
\begin{algorithmic}[1]
\Function{minimax}{$v$}
\If {$jestLisciem(v)$}
	\State \Return $funkcjaOceniajacaDlaGraczaMax(v)$
\EndIf
\If {$aktualyGracz(s) == graczMax$}
	\State \Return $max$($minimax(s) | s \in synowie(v))$
\Else
	\State \Return $max$($minimax(s) | s \in synowie(v))$
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

Znaj±c warto¶ci \(minimax\) dla synów korzenia, mo¿emy wybraæ najkorzystniejszy ruch w obecnym stanie gry.

\subsection{Alfa-Beta}

\subsection{Dalsze ulepszenia}

TODO tablica transpozycji, MTD-f, NegaScout, PVS

\section{Metody Monte Carlo}

TODO

\section{Odniesienie przedstawionych metod do tej pracy}

TODO

\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Bibliografia}
\end{thebibliography}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
